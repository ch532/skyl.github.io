<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Primary Meta Tags -->
<title>Skyl P World – Smart Widgets, News, Tools & Affiliate Deals</title>
<meta name="description" content="Skyl P World connects you with smart tools, trending news, and top affiliate-powered deals across, travel, and finance. Discover more in one click.">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://www.skyl.name.ng/">
<meta property="og:title" content="Skyl P World – Smart Widgets, News & Deals">
<meta property="og:description" content="Explore Skyl P World – where mobile tools, real-time news, and global deals from Trip.com, and more come together.">
<meta property="og:image" content="SkylPWorld_copy_512x512.png">

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:url" content="https://www.skyl.name.ng/">
<meta name="twitter:title" content="Skyl P World – News, Deals & Smart Tools">
<meta name="twitter:description" content="Widgets, affiliate tools, live news feeds and trending app resources – all in one mobile-friendly hub.">
<meta name="twitter:image" content="SkylPWorld_copy_512x512.png"> 
  ">

<!-- SEO & Mobile Optimization -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="index, follow">
<meta name="author" content="Skyl P World">
<meta name="keywords" content="Skyl P World, affiliate widgets, news widgets, travel tools, Trip.com partner, Wise finance, widget-based apps">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Connect Gold - Travel & Deals</title>
<script async src="https://cdn.start.io/sdk/latest/start.js"></script>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background: #f9f9f9;
      padding: 10px;
      text-align: center;
    }
    iframe.adbanner {
      width: 100%;
      height: 100px;
      border: none;
    }
    nav {
      background: #333;
      color: #fff;
      text-align: center;
      padding: 10px;
    }
    nav a {
      color: #fff;
      margin: 0 15px;
      text-decoration: none;
      font-weight: bold;
    }
    .widget-container {
      padding: 10px;
    }
    footer {
      margin-top: 30px;
      text-align: center;
      font-size: 12px;
      color: #777;
    }
  </style>
</head>
<body>

  <!-- Start.io Ad Container for Banner -->
<div id="banner" style="width:100%; height:90px;"></div>

<!-- Start.io Script -->
<script type="text/javascript">
  (function() {
    var s = document.createElement('script');
    s.src = "https://cdn.start.io/sdk/start.min.js"; // Example SDK URL
    s.async = true;
    s.onload = function() {
      // Initialize Start.io
      startio.init({
        appId: "208934944",   // Replace with your Start.io app ID
        banner: { container: "banner" },
        interstitial: { autoShow: true },
        rewarded: { autoShow: true }
      });

      // Optional: Listen to events
      startio.on('rewardedCompleted', function(info) {
        console.log("Reward granted:", info);
      });
    };
    document.head.appendChild(s);
  })();
</script>

<script>  
  import * as THREE from 'three';
let scene, camera, renderer, ambientLight, dirLight, player, floor, leftWall, rightWall, hudCanvas, hudTexture, hudMesh;
let gameState = 'start';
let lanes = [-2, 0, 2];
let playerLane = 1;
let moveTargetLane = 1;
let moveLerp = 0;
let moveSpeed = 0.18;
let leftPressed = false, rightPressed = false;
let obstacles = [];
let relicShards = [];
let lastObstacleZ = 0;
let lastRelicZ = 0;
let obstaclePool = [];
let relicPool = [];
let clock = new THREE.Clock();
let scrollZ = 0;
let gameSpeed = 0.22;
let gameTime = 0;
let coins = 0;
let nextObstacleTime = 0;
let nextRelicTime = 0;
let obstacleInterval = 1.2;
let relicInterval = 0.7;
let cameraYOffset = 2.5;
let cameraZOffset = 6;
let floorLength = 80;
let wallHeight = 4;
let trackWidth = 6;
let playerWobble = 0;
let playerWobbleVel = 0;
let playerMesh, playerBox;
let tmpBox = new THREE.Box3();
let obstacleBoxes = [];
let relicBoxes = [];
let fontSize = 60;
let lastCoins = 0;
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x10141b);
    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 60);
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    ambientLight = new THREE.AmbientLight(0x888888, 1.1);
    scene.add(ambientLight);
    dirLight = new THREE.DirectionalLight(0xffffff, 0.85);
    dirLight.position.set(5, 10, 6);
    scene.add(dirLight);
    player = new THREE.Group();
    let playerMat = new THREE.MeshPhongMaterial({
        color: 0x8ed9e3,
        shininess: 80,
        specular: 0xbfd9ff,
        emissive: 0x0e3d5d,
        emissiveIntensity: 0.12
    });
    playerMesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), playerMat);
    player.add(playerMesh);
    player.position.set(lanes[playerLane], 0.5, 0);
    scene.add(player);
    playerBox = new THREE.Box3();
    let floorMat = new THREE.MeshStandardMaterial({color: 0x23272e, roughness: 0.6, metalness: 0.25});
    floor = new THREE.Mesh(new THREE.BoxGeometry(trackWidth, 0.1, floorLength), floorMat);
    floor.position.set(0, 0, floorLength/2-10);
    scene.add(floor);
    let wallMat = new THREE.MeshStandardMaterial({color: 0x181b21, roughness: 0.7, metalness: 0.15});
    leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, wallHeight, floorLength), wallMat);
    leftWall.position.set(-trackWidth/2, wallHeight/2, floorLength/2-10);
    scene.add(leftWall);
    rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, wallHeight, floorLength), wallMat);
    rightWall.position.set(trackWidth/2, wallHeight/2, floorLength/2-10);
    scene.add(rightWall);
    hudCanvas = document.createElement('canvas');
    hudCanvas.width = 1024;
    hudCanvas.height = 256;
    hudTexture = new THREE.CanvasTexture(hudCanvas);
    let hudMaterial = new THREE.MeshBasicMaterial({map: hudTexture, transparent: true});
    hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 2), hudMaterial);
    hudMesh.position.set(0, 4, -4.5);
    hudMesh.renderOrder = 999;
    camera.add(hudMesh);
    scene.add(camera);
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    resetGame();
    animate();
}
function resetGame() {
    gameState = 'start';
    playerLane = 1;
    moveTargetLane = 1;
    moveLerp = 0;
    player.position.set(lanes[playerLane], 0.5, 0);
    playerWobble = 0;
    playerWobbleVel = 0;
    scrollZ = 0;
    gameSpeed = 0.22;
    gameTime = 0;
    coins = 0;
    lastCoins = 0;
    nextObstacleTime = 0.8;
    nextRelicTime = 0.5;
    lastObstacleZ = 18;
    lastRelicZ = 12;
    for (let o of obstacles) scene.remove(o.mesh);
    for (let r of relicShards) scene.remove(r.mesh);
    obstacles = [];
    relicShards = [];
    obstaclePool = [];
    relicPool = [];
    obstacleBoxes = [];
    relicBoxes = [];
}
function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
function onKeyDown(e) {
    if (gameState === 'start') {
        if (e.code === 'Space') {
            gameState = 'play';
        }
    } else if (gameState === 'play') {
        if (e.code === 'ArrowLeft' || e.code === 'KeyA') leftPressed = true;
        if (e.code === 'ArrowRight' || e.code === 'KeyD') rightPressed = true;
    } else if (gameState === 'gameover') {
        if (e.code === 'KeyR') {
            resetGame();
        }
    }
}
function onKeyUp(e) {
    if (gameState !== 'play') return;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') leftPressed = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') rightPressed = false;
}
function tryMoveLane(dir) {
    if (moveTargetLane === playerLane && moveLerp === 0) {
        let next = playerLane + dir;
        if (next >= 0 && next <= 2) {
            moveTargetLane = next;
            moveLerp = 1;
            playerWobbleVel = -dir * 0.17;
        }
    }
}
function animate() {
    requestAnimationFrame(animate);
    let dt = Math.min(clock.getDelta(), 0.05);
    if (gameState === 'play') {
        gameTime += dt;
        gameSpeed = 0.22 + Math.min(0.48, gameTime*0.025);
        scrollZ += gameSpeed;
        if (leftPressed) tryMoveLane(-1);
        if (rightPressed) tryMoveLane(1);
        if (moveTargetLane !== playerLane) {
            let dir = Math.sign(moveTargetLane - playerLane);
            let step = moveSpeed * dt * 60;
            let px = THREE.MathUtils.lerp(lanes[playerLane], lanes[moveTargetLane], 1-moveLerp);
            moveLerp -= step;
            if (moveLerp <= 0) {
                moveLerp = 0;
                playerLane = moveTargetLane;
            }
            player.position.x = THREE.MathUtils.lerp(lanes[playerLane], lanes[moveTargetLane], moveLerp);
        } else {
            player.position.x = lanes[playerLane];
        }
        playerWobble += playerWobbleVel;
        playerWobble *= 0.85;
        playerWobbleVel *= 0.7;
        playerMesh.rotation.z = playerWobble;
        playerMesh.rotation.x = Math.sin(gameTime*2.5)*0.05;
        let baseZ = scrollZ;
        floor.position.z = baseZ + floorLength/2-10;
        leftWall.position.z = baseZ + floorLength/2-10;
        rightWall.position.z = baseZ + floorLength/2-10;
        spawnObstaclesAndRelics();
        for (let i=obstacles.length-1; i>=0; --i) {
            let o = obstacles[i];
            o.mesh.position.z -= gameSpeed;
            if (o.mesh.position.z < -3) {
                scene.remove(o.mesh);
                obstaclePool.push(o);
                obstacles.splice(i,1);
                obstacleBoxes.splice(i,1);
            }
        }
        for (let i=relicShards.length-1; i>=0; --i) {
            let r = relicShards[i];
            r.mesh.position.z -= gameSpeed;
            r.mesh.rotation.y += dt*2.5;
            r.mesh.rotation.x += dt*1.2;
            if (r.mesh.position.z < -3) {
                scene.remove(r.mesh);
                relicPool.push(r);
                relicShards.splice(i,1);
                relicBoxes.splice(i,1);
            }
        }
        playerBox.setFromObject(playerMesh);
        for (let i=0; i<obstacles.length; ++i) {
            let o = obstacles[i];
            tmpBox.copy(obstacleBoxes[i]);
            tmpBox.min.add(o.mesh.position);
            tmpBox.max.add(o.mesh.position);
            if (playerBox.intersectsBox(tmpBox)) {
                gameState = 'gameover';
                lastCoins = coins;
                showInterstitialAd();
            }
        }
        for (let i=relicShards.length-1; i>=0; --i) {
            let r = relicShards[i];
            tmpBox.copy(relicBoxes[i]);
            tmpBox.min.add(r.mesh.position);
            tmpBox.max.add(r.mesh.position);
            if (playerBox.intersectsBox(tmpBox)) {
                coins += 1;
                scene.remove(r.mesh);
                relicPool.push(r);
                relicShards.splice(i,1);
                relicBoxes.splice(i,1);
            }
        }
    } else if (gameState === 'start') {
        playerMesh.rotation.y += dt*0.7;
        playerMesh.rotation.x = Math.sin(performance.now()*0.001)*0.05;
    }
    let camTargetZ = player.position.z + cameraZOffset;
    camera.position.x = 0;
    camera.position.y = cameraYOffset;
    camera.position.z = camTargetZ;
    camera.lookAt(player.position.x, 0.75, player.position.z+6);
    updateHUD();
    renderer.render(scene, camera);
}
function spawnObstaclesAndRelics() {
    if (gameTime > nextObstacleTime) {
        let obsType = Math.random();
        let lane = Math.floor(Math.random()*3);
        let z = scrollZ + 30;
        if (obsType < 0.5) {
            spawnObstacle('single', lane, z);
        } else if (obsType < 0.8) {
            let doubleLane = Math.floor(Math.random()*2);
            spawnObstacle('double', doubleLane, z);
        } else {
            spawnObstacle('gap', 0, z);
        }
        let interval = obstacleInterval - Math.min(0.8, gameTime*0.035);
        nextObstacleTime = gameTime + interval*(0.94+Math.random()*0.12);
    }
    if (gameTime > nextRelicTime) {
        let freeLanes = [0,1,2];
        if (obstacles.length > 0) {
            let lastObs = obstacles[obstacles.length-1];
            if (lastObs.type === 'single') freeLanes = freeLanes.filter(l=>l!==lastObs.lane);
            if (lastObs.type === 'double') freeLanes = freeLanes.filter(l=>l!==lastObs.lane && l!==(lastObs.lane+1));
            if (lastObs.type === 'gap') freeLanes = [1];
        }
        let lane = freeLanes[Math.floor(Math.random()*freeLanes.length)];
        let z = scrollZ + 30.5;
        spawnRelicShard(lane, z);
        let interval = relicInterval - Math.min(0.45, gameTime*0.02);
        nextRelicTime = gameTime + interval*(0.92+Math.random()*0.15);
    }
}
function spawnObstacle(type, lane, z) {
    let mesh, box, o;
    if (obstaclePool.length > 0) {
        o = obstaclePool.pop();
        mesh = o.mesh;
        mesh.visible = true;
    } else {
        let mat = new THREE.MeshStandardMaterial({color: 0x26292e, roughness: 0.85, metalness: 0.25});
        mesh = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), mat);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        o = {mesh, type: '', lane: 0};
    }
    mesh.position.y = 0.525;
    mesh.position.z = z;
    if (type === 'single') {
        mesh.geometry = new THREE.BoxGeometry(1.05,1.05,1.05);
        mesh.position.x = lanes[lane];
        box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(1.05,1.05,1.05));
        o.type = 'single';
        o.lane = lane;
    } else if (type === 'double') {
        mesh.geometry = new THREE.BoxGeometry(2.1,1.05,1.05);
        mesh.position.x = (lanes[lane] + lanes[lane+1])/2;
        box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(2.1,1.05,1.05));
        o.type = 'double';
        o.lane = lane;
    } else if (type === 'gap') {
        mesh.geometry = new THREE.BoxGeometry(1.05,1.05,1.05);
        mesh.position.x = lanes[0];
        box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(1.05,1.05,1.05));
        let mesh2, box2, o2;
        if (obstaclePool.length > 0) {
            o2 = obstaclePool.pop();
            mesh2 = o2.mesh;
            mesh2.visible = true;
        } else {
            let mat = new THREE.MeshStandardMaterial({color: 0x26292e, roughness: 0.85, metalness: 0.25});
            mesh2 = new THREE.Mesh(new THREE.BoxGeometry(1.05,1.05,1.05), mat);
            mesh2.castShadow = false;
            mesh2.receiveShadow = false;
            o2 = {mesh: mesh2, type: '', lane: 0};
        }
        mesh2.position.y = 0.525;
        mesh2.position.z = z;
        mesh2.position.x = lanes[2];
        box2 = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(1.05,1.05,1.05));
        o2.type = 'gap';
        o2.lane = 2;
        obstacles.push(o2);
        obstacleBoxes.push(box2);
        scene.add(mesh2);
        o.type = 'gap';
        o.lane = 0;
    }
    obstacles.push(o);
    obstacleBoxes.push(box);
    scene.add(mesh);
}
function spawnRelicShard(lane, z) {
    let mesh, box, r;
    if (relicPool.length > 0) {
        r = relicPool.pop();
        mesh = r.mesh;
        mesh.visible = true;
    } else {
        let geom = new THREE.OctahedronGeometry(0.18);
        let mat = new THREE.MeshBasicMaterial({color: 0x27f7e7, emissive: 0x27f7e7, emissiveIntensity: 1});
        mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        r = {mesh};
    }
    mesh.position.x = lanes[lane];
    mesh.position.y = 0.7;
    mesh.position.z = z;
    mesh.rotation.x = Math.random()*Math.PI;
    mesh.rotation.y = Math.random()*Math.PI;
    box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(0,0,0), new THREE.Vector3(0.35,0.35,0.35));
    relicShards.push(r);
    relicBoxes.push(box);
    scene.add(mesh);
}
function updateHUD() {
    let ctx = hudCanvas.getContext('2d');
    ctx.clearRect(0,0,hudCanvas.width,hudCanvas.height);
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    if (gameState === 'start') {
        ctx.shadowColor = '#27f7e7';
        ctx.shadowBlur = 16;
        ctx.fillText('CUBE RUNNER: RELIC RETRIEVAL', hudCanvas.width/2, 90);
        ctx.shadowBlur = 0;
        ctx.font = `bold ${fontSize*0.7}px Arial`;
        ctx.fillStyle = '#b2e4f9';
        ctx.fillText('Press SPACE to Start', hudCanvas.width/2, 170);
    } else if (gameState === 'play') {
        ctx.font = `bold ${fontSize*0.9}px Arial`;
        ctx.textAlign = 'right';
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#27f7e7';
        ctx.shadowBlur = 8;
        ctx.fillText(`Coins: ${coins}`, hudCanvas.width-40, 75);
        ctx.shadowBlur = 0;
    } else if (gameState === 'gameover') {
        ctx.shadowColor = '#ff2d2d';
        ctx.shadowBlur = 18;
        ctx.font = `bold ${fontSize*1.2}px Arial`;
        ctx.fillStyle = '#fff';
        ctx.fillText('GAME OVER!', hudCanvas.width/2, 105);
        ctx.shadowBlur = 0;
        ctx.font = `bold ${fontSize*0.9}px Arial`;
        ctx.fillStyle = '#b2e4f9';
        ctx.fillText(`Coins Collected: ${lastCoins}`, hudCanvas.width/2, 170);
        ctx.font = `bold ${fontSize*0.7}px Arial`;
        ctx.fillStyle = '#b2e4f9';
        ctx.fillText(`Press R to Restart`, hudCanvas.width/2, 220);
    }
    hudTexture.needsUpdate = true;
}
function showInterstitialAd() {
    console.log("Unity Ads: Integration not possible due to 'no external libraries' constraint. Showing simulated ad.");
    gameState = 'ad_showing';
    setTimeout(() => {
        console.log("Unity Ads: Simulated interstitial ad closed.");
        gameState = 'gameover';
    }, 3000);
}
init();
        </script>         

</body>
</html>
  

